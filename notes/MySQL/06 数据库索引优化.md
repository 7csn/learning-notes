# 数据库索引优化

#### MySQL索引

MySQL索引在存储引擎层实现

使用索引原因：
* 索引大大减少了存储引擎需要扫描的数据量
* 索引可以帮助我们进行排序以避免使用临时表
* 所以可以把随机I/O变为顺序I/O

索引是不是越多越好：
* 增加写操作的成本
* 太多索引会增加查询优化器的选择时间

MySQL支持的索引类型：

* B-tree索引特点
    * 以B+树的结构存储数据

        ![B+树](./img/06.1.png?raw=true "B+树")
    * 能加快数据的查询速度
    * 更适合范围查找
* Hash索引
    * 基于Hash表实现，只有查询条件精确匹配Hash索引中的所有列时，才能够使用到hash索引
    * 对Hash索引中所有列，存储引擎都会为每行计算一个Hash码，Hash索引中存储的就是Hash码

什么时候可用到B树索引：
* 全值匹配的查询
* 匹配最左前缀的查询（联合索引左侧）
* 匹配列前缀查询（like '前缀%'）
* 匹配范围值的查询
* 精确匹配左前列并范围匹配另外一列
* 只访问索引的查询（索引覆盖）

Btree索引的使用限制：
* 若不是按索引最左列开始查找，无法使用索引
* 使用索引时不能跳过索引中的列
* not in 和 <> 操作无法使用索引
* 若查询中有某个列的范围查询，则其右边所有列无法使用索引

Hash索引的限制：
* 必须进行二次查找
* 无法用于排序
* 不支持部分索引查找，不支持范围查找
* Hash码的计算可能存在Hash冲突

#### 安装演示数据库

```
# 下载演示数据库压缩包
> wget http://downloads.mysql.com/docs/sakila-db.tar.gz

> tar -zxf sakila-db.tar.gz

> cd sakila-db

# 导入数据库表结构
> mysql -uroot -p < sakila-schema.sql

# 导入表数据
> mysql -uroot -p < sakila-data.sql
```

#### 索引优化策略
* 索引列上不能使用表达式或函数
    
    ![索引列函数示例](./img/06.2.png?raw=true "索引列函数示例")
* 前缀索引和索引列的选择性

    CREATE INDEX index_name ON table_name (lol_name(n));
    
    索引的选择性是不重复的索引值和表的记录数的比值
* 联合索引

    如何选择索引列的顺序
    * 经常会备使用到的列优先
    * 选择性高的列优先
    * 宽度小的列优先

* 覆盖索引

    只查询索引列且全部列都用上了索引
    
    优点：
    * 可以优化缓存，减少磁盘IO操作
    * 可以减少随机IO，变随机IO操作变为顺序IO操作
    * 可以避免对Innodb主键索引的二次查询
    * 可以避免MyISAM表进行系统调用
    
    无法使用覆盖索引的情况：
    * 存储引擎不支持覆盖索引
    * 查询中使用了太多的列
    * 使用了双%号的like查询

* 使用索引扫描来优化排序
    * 索引的列顺序和order by子句顺序完全一致
    * 索引中所有列的方向（升序，降序）和order by子句完全一致
    * order by中的字段全部在关联表中的第一张中

* 模拟Hash索引优化查询
    * 只能处理键值的全职匹配查找
    * 所使用的hash函数决定索引键的大小

* 利用索引优化锁
    * 索引可以减少锁定的行数
    * 索引可以加快处理速度，同时也加快锁的释放

* 索引的维护和优化
    * 删除重复和冗余索引 
    
        ![重复和冗余索引](./img/06.3.png?raw=true "重复和冗余索引")

        检测重复和冗余的索引：
        
        `> pt-duplicate-key-checker h=127.0.0.1`
        
        ![检测结果](./img/06.4.png?raw=true "检测结果")
    * 查找未被使用过的索引
    
        ![索引使用记录查询](./img/06.5.png?raw=true "索引使用记录查询")
    * 更新索引统计信息及减少索引碎片
    
        ```
        # 更新索引统计信息
        mysql> analyze table 表名 # Myisam需要全索引扫描；Innodb效率高，但不准确
    
        # 减少索引碎片
        mysql> optimize table 表名 # 会锁表
        ```
