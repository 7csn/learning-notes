# MySQL数据库结构优化

数据库结构优化的目的：

* 减少数据冗余

* 尽量避免数据维护中出现更新、插入和删除异常
    * 插入异常：如果表中的某个实体随着另一个实体而存在
    * 更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新
    * 删除异常：如果删除表中的某一实体，会导致其他实体的消失

* 节约数据存储空间

* 提高查询效率

数据库设计的步骤：

* 需求分析：

    全面了解产品设计的存储需、数据处理需求、数据的安全性和完整性

* 逻辑设计：

    设计数据的逻辑存储结构，数据实体间的逻辑关系，解决数据冗余和数据维护异常

* 物理设计：根据所使用的数据库特点进行表设计

    关系型：Oralce、SQLServer、MYSQL、postgresSQL
    
    非关系型：mongo、Redis、Hadoop
    
    存储引擎：Innodb

* 维护优化：根据实际情况对索引、存储结构等进行优化

数据库设计范式：

* 第一范式：表中每列具有原子性，不可再分割

    * 表中所有字段只具有单一属性
    
    * 单一属性的列是由基本数据类型所构成
    
    * 表都是简单的二维表

* 第二范式：属性完全依赖主键

    * 一个表中只有一个业务主键，如果是复合主键，不能存在非主键对部分主键的依赖关系

* 第三范式：非主属性不依赖于其他非主属性

    * 非主键不部分依赖于也不传递依赖于业务主键，在第二范式基础上，消除非主键对主键的传递依赖

反范式化设计：

* 反范式化是针对范式化而言，为了性能和读取效率的考虑，适当的对数据库设计范式的要求进行违反，而运行存在少量的数据冗余，用空间换取时间

* 有时为了维护数据的准确性，也会违反范式化，添加数据冗余，比如订单表金额等，防止被关联修改

范式化设计优缺点：

* 优点：
    
    * 尽量减少数据冗余，表更新快体积小
    
    * 更新操作更快 

    * 表更小

* 缺点：

    * 对查询需要对夺标关联
    
    * 更难进行索引优化

反范式化设计优缺点：

* 优点：

    * 减少表的关联
    
    * 更好的进行索引优化

* 缺点：

    * 存在数据冗余及数据维护异常
    
    * 数据修改需要更多的成本

物理设计设计的内容：

* 定义数据库、表及字段的命名规范

    * 可读性原则
    
    * 表意性原则
    
    * 长名原则

* 选择合适的存储引擎

    ![存储引擎](./img/04.1.png?raw=true "存储引擎")

* 为表中的字段选择合适的数据类型

    * 数字类型 > 日期/二进制类型 > 字符类型
    
    * 同级别数据类型，优先选占用空间小的
    
    正确选择整数类型：
    ![整数类型](./img/04.2.png?raw=true "整数类型")
    
    正确选择实数类型：
    ![实数类型](./img/04.3.png?raw=true "实数类型")
    
    选择varchar和char类型：
    
    * varchar存储特点：
        
        * 变长，只占必要的存储空间
        
        * 列最大长度小于255，则只占用一个额外字节记录字符串长度
        
        * 列最大长度大于255，则占用两个额外字节用于记录字符串长度
        
        * Innodb单行所有verchar总上限65535
        
    * varchar长度选择（5.7前修改锁表，5.7+255内修改不锁表）：
        
        * 使用最小的符合需求的长度
        
        * 过长浪费内存，性能降低
        
    * varchar适用场景：
    
        * 字符串列最大长度比平均长度大很多
        
        * 字符串列很少被更新（变长，更新容易产生存储页分裂，造成碎片）
        
        * 使用了多字节字符集存储字符串
    
    * char类型存储特点
    
        * 定长
        
        * 数据末尾空格会被删除
        
        * 最大宽度255
        
    * char适用场景：
    
        * 存储长度近似的值
        
        * 存储端字符串
        
        * 存储经常被更新的字符串
    
    存储日期数据：
    
    * datatime类型：YYYY-MM-DD HH:MM:SS[.fraction]
    
        * datetime = YYYY-MM-DD HH:MM:SS
    
        * datetime(6) = YYYY-MM-DD HH:MM:SS.fraction 5.6+版本
        
        * 该类型与时区无关，占用8个字节存储空间
        
        * 1000-01-01 00:00:00 到 9999-12-31 23:59:59
    
    * timestamp类型：YYYY-MM-DD HH:MM:SS[.fraction]
    
        * timestamp = YYYY-MM-DD HH:MM:SS
    
        * timestamp(6) = YYYY-MM-DD HH:MM:SS.fraction
    
        * 占用4个字节：1970-01-01 到 2038-01-19
        
        * 格林尼治1970年1月1日到当前的秒数，显示依赖于指定的时区
        
        * 行的数据修改时，默认首个timestamp自动更新（可于建表语句中指定）
        
    date和time类型：
    
    * date类型优点：
    
        * 占用字节数比字符串、datetime、int少，仅3个字节
        
        * 可以用日期函数进行日期间计算
        
        * 1000-01-01 到 9999-12-31
    
    * time类型用于存储时间数据，格式：HH:MM:SS
    
    存储日期时间数据注意事项：
    
    * 不要用字符串类型
    
        * 日期时间类型占用存储空间小
        
        * 日期时间类型在进行查找过滤时可以利用日期进行对比
        
        * 日期时间类型有丰富的处理函数，可方便的对日期类型进行日期金酸
    
    * 使用int存储日期时间不如timestamp

* 建立数据库的结构

#### 总结
* 优先选择Innodb
* Innodb主键：尽可能小，是顺序增长的，和业务主键可以不同
