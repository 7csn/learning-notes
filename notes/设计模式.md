## SOLID 设计原则
遵循设计模式中的 SOLID 五大原则可以使程序解决紧耦合，更加健壮。
|名称|解释|
|-|-|
|SRP|单一责任原则|
|OCP|开放封闭原则|
|LSP|里氏替换原则|
|ISP|接口隔离原则|
|DIP|依赖倒置原则|

##### 单一责任原则 SRP
指一个类或一个方法只做一件事。  
若一个类承担职责过多，职责耦合在一起，一个职责的变化就可能抑制或削弱类完成其它职责的能力。

##### 开放封闭原则 OCP
对扩展开放，对修改关闭。  
类独立后不应该修改，而是以扩展方式适应新需求。

##### 里氏替换原则 LSP
所有基类可由派生类替换，程序不会出错。  
子类可扩展父类功能，但不能改变原有功能。

##### 接口隔离原则 ISP
类不应依赖不需要的接口，知道越少越好。

##### 依赖倒置原则 DIP
高级模块不应依赖低级模块，而应依赖抽象。  
抽象不应依赖细节，细节要依赖抽象。

## 常用设计模式
1. 单例  

    类静态创建自身唯一对象，并防止外界直接创建。
    
    通过提供自身共享实例的访问，单例设计模式用于限制特定对象只能被创建一次。

2. 观察者

    观察者群体观察某主题，当主题发生变化时，引发观察者行为。  
    
    观察者设计模式能够更便利创建和查看目标对象状态的对象，并且提供和核心对象非耦合的置顶功能性。  
    观察者设计模式非常常用，在一般复杂的 WEB 系统中，观察者模式可以帮你减轻代码设计的压力，降低代码耦合。

3. 中介者（不常用）

    开发一个类似对象集合的中介对象，使集合某对象能够通过中介对象将修改同步到集合其它对象中。  
    
    中介者模式用于开发一个对象，这个对象能够在类似对象相互之间不直接相互的情况下传送或者调解对这些对象的集合的修改。  
    一般处理具有类似属性，需要保持同步的非耦合对象时，最佳的做法就是中介者模式。  

4. 迭代器（Iterator 接口实现，不常用）

    可帮助构造特定的对象，那些对象能够提供单一标准接口循环或迭代任何类型的可计数数据。

    使用场景：
    1. 访问一个聚合对象的内容而无需暴露它的内部表示。
    2. 支持对聚合对象的多种遍历。
    3. 为遍历不同的聚合结构提供一个统一的接口 (即，多态迭代)。
    
    php >= 5.5，yield 生成器实现。

5. 解释器（常用，如模板引擎）

    用于分析一个实体的关键元素，并且针对每个元素提供自己的解释或相应动作。

6. 外观

    通过在必需的逻辑和方法的集合前创建简单的外观接口，外观设计模式隐藏了调用对象的复杂性。
    
    外观设计模式和建造者模式非常相似，建造者模式一般是简化对象的调用的复杂性，外观模式一般是简化含有很多逻辑步骤和方法调用的复杂性。

    场景举例：Users类信息多且变化，getUser接口前，需进行大量设置；设计UserFacade类静态getUserCall调用User的getUser。

7. 委托

    通过分配或委托其他对象，委托设计模式能够去除核心对象中的判决和复杂的功能性。
    
    场景举例：通过传参由CD委托对象的play决定播放MP3或MP4。
    
8. 装饰器

    装饰器模式，对已有对象的部分内容或者功能进行调整，但是不需要修改原始对象结构。

9. 数据访问对象

    用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。
    
    数据访问对象模式描述了如何创建透明访问数据源的对象。

10. 适配器

    将某个对象的接口适配为另一个对象所期望的接口。
    
    适配器充当两个不匹配接口的桥梁。

11. 策略

    策略模式设计帮助构建的对象不必自身包含逻辑，而是能够根据需要利用其他对象中的算法。

    购买一组产品（每个产品有多家商店生产），通过策略商店，指定各产品的来源商店。

12. 工厂（常用，常配合单例）

    提供获取某个对象实例的一个接口，同时使调用代码避免确定实例化基类的步骤。
    
    工厂模式实际上就是建立一个统一的类实例化的函数接口。统一调用，统一控制。

13. 建造者

    建造者模式主要是为了消除其它对象复杂的创建过程。
